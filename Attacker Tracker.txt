-- Attacker Tracker (UI & logic cleanup)
-- Reworked UI: fixed overlap, scaling, CanvasSize, page visibility, and stable list updates.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TextChatService = game:GetService("TextChatService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ====================
-- CONFIG
-- ====================
local INACTIVITY_TIMEOUT = 5
local UI_POLL = 0.20
local HISTORY_MAX = 400
local RECENT_HIT_WINDOW = 4
local KILL_DETECTION_WINDOW = 6

-- cosmetic base
local UI_BASE_W, UI_BASE_H = 420, 340

-- ====================
-- Utility helpers (kept your core logic largely intact)
-- ====================
local function safeFindFightRemote()
    local candidates = {"FightEvent", "FightRemote", "DamageEvent", "HitEvent"}
    for _, name in ipairs(candidates) do
        local r = ReplicatedStorage:FindFirstChild(name)
        if r and r:IsA("RemoteEvent") then return r end
    end
    for _, v in ipairs(ReplicatedStorage:GetChildren()) do
        if v:IsA("RemoteEvent") then
            local lower = tostring(v.Name):lower()
            if lower:match("fight") or lower:match("hit") then return v end
        end
    end
    return nil
end
local FightRemote = safeFindFightRemote()

local function now() return os.clock() end

local attackers = {}
local history = {}
local recentHits = {}

local function registerAttacker(name)
    if not name or name == "" then return end
    local t = now()
    local entry = attackers[name]
    if entry then
        entry.lastHit = t
        entry.hits = entry.hits + 1
    else
        attackers[name] = { lastHit = t, hits = 1, firstSeen = t }
    end
end

local function archiveAttacker(name)
    local entry = attackers[name]
    if not entry then return end
    table.insert(history, 1, {
        name = name,
        timeFirst = entry.firstSeen,
        timeLast = entry.lastHit,
        hits = entry.hits
    })
    while #history > HISTORY_MAX do table.remove(history) end
    attackers[name] = nil
end

local function cleanupInactive()
    local t = now()
    for name, data in pairs(attackers) do
        if t - data.lastHit >= INACTIVITY_TIMEOUT then
            archiveAttacker(name)
        end
    end
end

local function extractNameFromPayload(a)
    if not a then return nil end
    if typeof(a) == "Instance" and a:IsA("Player") then return a.Name end
    if type(a) == "string" then return a end
    if type(a) == "table" then
        if a.attacker and typeof(a.attacker) == "Instance" and a.attacker:IsA("Player") then return a.attacker.Name end
        if a.attackerName and type(a.attackerName) == "string" then return a.attackerName end
        if a[1] and typeof(a[1]) == "Instance" and a[1]:IsA("Player") then return a[1].Name end
    end
    return nil
end

local function findCreatorTagAnywhere()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") or obj:IsA("Model") then
            local creator = obj:FindFirstChild("creator") or obj:FindFirstChild("Creator") or obj:FindFirstChild("Owner")
            if creator and creator.Value then
                if typeof(creator.Value) == "Instance" and creator.Value:IsA("Player") then
                    return creator.Value.Name
                elseif type(creator.Value) == "string" then
                    return creator.Value
                end
            end
        end
    end
    return nil
end

local function scanClosestPlayer()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
    local myPos = char.HumanoidRootPart.Position
    local best, bestScore = nil, math.huge
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local d = (pl.Character.HumanoidRootPart.Position - myPos).Magnitude
            local hasTool = false
            for _, c in ipairs(pl.Character:GetChildren()) do
                if c:IsA("Tool") then hasTool = true; break end
            end
            local score = d - (hasTool and 2 or 0)
            if score < bestScore then bestScore, best = score, pl end
        end
    end
    return best and best.Name or nil
end

-- FightRemote hook
if FightRemote and FightRemote:IsA("RemoteEvent") then
    pcall(function()
        FightRemote.OnClientEvent:Connect(function(...)
            local args = {...}
            local attackerName = extractNameFromPayload(args[1]) or extractNameFromPayload(args[2])
            if attackerName then registerAttacker(attackerName) end

            local victimName
            if #args >= 2 then
                if typeof(args[2]) == "Instance" and args[2]:IsA("Player") then victimName = args[2].Name end
                if type(args[2]) == "string" then victimName = args[2] end
            end
            if victimName and attackerName and victimName == LocalPlayer.Name then
                registerAttacker(attackerName)
            end
            if victimName and attackerName and attackerName == LocalPlayer.Name then
                recentHits[victimName] = now()
            end
        end)
    end)
end

-- Health watcher fallback
local lastHealth = nil
local function hookHealth()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    lastHealth = humanoid.Health
    humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        local new = humanoid.Health
        if new < (lastHealth or new) then
            local name = findCreatorTagAnywhere() or scanClosestPlayer() or "Unknown"
            registerAttacker(name)
        end
        lastHealth = new
    end)
end
Players.LocalPlayer.CharacterAdded:Connect(function() task.wait(0.4); pcall(hookHealth) end)
if Players.LocalPlayer.Character then pcall(hookHealth) end

-- Kill / death detection (unchanged in behaviour)
local killTrack = {}
local selectedForKillTrack = nil
local function ensurePlayerCharacterConnections(pl)
    if not pl or not pl:IsA("Player") then return end
    local function onChar(char)
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then humanoid = char:WaitForChild("Humanoid", 3); if not humanoid then return end end
        humanoid.Died:Connect(function()
            local killerName = nil
            local creator = humanoid:FindFirstChild("creator") or humanoid:FindFirstChild("Creator")
            if creator and creator.Value then
                if typeof(creator.Value) == "Instance" and creator.Value:IsA("Player") then
                    killerName = creator.Value.Name
                elseif type(creator.Value) == "string" then
                    killerName = creator.Value
                end
            end
            if not killerName then
                local last = recentHits[pl.Name]
                if last and now() - last <= KILL_DETECTION_WINDOW then killerName = LocalPlayer.Name end
            end
            if not killerName then killerName = findCreatorTagAnywhere() end
            if selectedForKillTrack and pl.Name == selectedForKillTrack and killerName == LocalPlayer.Name then
                killTrack[selectedForKillTrack] = killTrack[selectedForKillTrack] or {kills = 0, deaths = 0}
                killTrack[selectedForKillTrack].kills = (killTrack[selectedForKillTrack].kills or 0) + 1
            end
        end)
    end
    if pl.Character then onChar(pl.Character) end
    pl.CharacterAdded:Connect(onChar)
end
for _, pl in ipairs(Players:GetPlayers()) do ensurePlayerCharacterConnections(pl) end
Players.PlayerAdded:Connect(function(pl) ensurePlayerCharacterConnections(pl) end)

local function hookLocalDeath()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    humanoid.Died:Connect(function()
        local killerName = nil
        local creator = humanoid:FindFirstChild("creator") or humanoid:FindFirstChild("Creator")
        if creator and creator.Value then
            if typeof(creator.Value) == "Instance" and creator.Value:IsA("Player") then
                killerName = creator.Value.Name
            elseif type(creator.Value) == "string" then
                killerName = creator.Value
            end
        end
        if not killerName then killerName = findCreatorTagAnywhere() end
        if not killerName then killerName = "Unknown" end
        if selectedForKillTrack and killerName == selectedForKillTrack then
            killTrack[selectedForKillTrack] = killTrack[selectedForKillTrack] or {kills = 0, deaths = 0}
            killTrack[selectedForKillTrack].deaths = (killTrack[selectedForKillTrack].deaths or 0) + 1
        end
    end)
end
Players.LocalPlayer.CharacterAdded:Connect(function() task.wait(0.3); pcall(hookLocalDeath) end)
if Players.LocalPlayer.Character then pcall(hookLocalDeath) end

-- ====================
-- UI: safe creation + robust layout
-- ====================
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
if PlayerGui:FindFirstChild("AttackerTrackerGui") then PlayerGui.AttackerTrackerGui:Destroy() end

local screen = Instance.new("ScreenGui")
screen.Name = "AttackerTrackerGui"
screen.ResetOnSpawn = false
screen.Parent = PlayerGui
screen.DisplayOrder = 500

-- UIScale logic (more robust)
local uiScale = Instance.new("UIScale", screen)
local function computeScale()
    local vp = Camera and Camera.ViewportSize or Vector2.new(1280,720)
    local minDim = math.min(vp.X, vp.Y)
    if UserInputService.TouchEnabled then
        return math.clamp(minDim / 900, 0.56, 0.95)
    else
        return math.clamp(minDim / 1200, 0.88, 1.06)
    end
end
uiScale.Scale = computeScale()
-- Update when window size changes
if Camera then Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function() uiScale.Scale = computeScale() end) end

-- rainbow stroke registry (keeps your look)
local rainbowStrokes = {}
local function registerStroke(s) if s then table.insert(rainbowStrokes, s) end end
local function hsv(h,s,v) return Color3.fromHSV((h%1), s, v) end
spawn(function()
    while screen.Parent do
        local base = (tick() * 0.18) % 1
        local n = #rainbowStrokes
        if n > 0 then
            for i, st in ipairs(rainbowStrokes) do
                if st and st.Parent then
                    local offset = (i-1)/math.max(1,n) * 0.18
                    st.Color = hsv(base + offset, 0.92, 0.95)
                end
            end
        end
        task.wait(0.04)
    end
end)

-- main container (anchored center, off-screen when closed)
local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0, UI_BASE_W, 0, UI_BASE_H)
main.Position = UDim2.new(0.5, 0, -0.5, 0) -- off-screen above when closed
main.AnchorPoint = Vector2.new(0.5, 0.5)
main.BackgroundColor3 = Color3.fromRGB(18,18,22)
main.Parent = screen
local mainCorner = Instance.new("UICorner", main); mainCorner.CornerRadius = UDim.new(0, 10)
local mainStroke = Instance.new("UIStroke", main); mainStroke.Thickness = 2; registerStroke(mainStroke)
main.Visible = false

-- header
local header = Instance.new("Frame", main)
header.Size = UDim2.new(1, 0, 0, 56)
header.Position = UDim2.new(0, 0, 0, 0)
header.BackgroundColor3 = Color3.fromRGB(22,22,26)
local headerCorner = Instance.new("UICorner", header); headerCorner.CornerRadius = UDim.new(0, 10)
local headerStroke = Instance.new("UIStroke", header); headerStroke.Thickness = 1; registerStroke(headerStroke)

local title = Instance.new("TextLabel", header)
title.Size = UDim2.new(0.6, -12, 1, 0)
title.Position = UDim2.new(0, 12, 0, 0)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = Color3.fromRGB(230,230,230)
title.Text = "Attacker Tracking Hub"
local titleStroke = Instance.new("UIStroke", title); titleStroke.Thickness = 1; registerStroke(titleStroke)

local subtitle = Instance.new("TextLabel", header)
subtitle.Size = UDim2.new(0.4, -20, 1, 0)
subtitle.Position = UDim2.new(0.6, 0, 0, 0)
subtitle.BackgroundTransparency = 1
subtitle.TextXAlignment = Enum.TextXAlignment.Right
subtitle.Font = Enum.Font.Gotham
subtitle.TextSize = 12
subtitle.TextColor3 = Color3.fromRGB(190,190,190)
subtitle.Text = "Live — Press /tracker to open"
local subtitleStroke = Instance.new("UIStroke", subtitle); subtitleStroke.Thickness = 1; registerStroke(subtitleStroke)

-- left nav (fixed width)
local NAV_W = 96
local nav = Instance.new("Frame", main)
nav.Size = UDim2.new(0, NAV_W, 1, -56)
nav.Position = UDim2.new(0, 0, 0, 56)
nav.BackgroundColor3 = Color3.fromRGB(20,20,24)
local navCorner = Instance.new("UICorner", nav); navCorner.CornerRadius = UDim.new(0, 8)
local navStroke = Instance.new("UIStroke", nav); navStroke.Thickness = 1; registerStroke(navStroke)

-- content area (remaining space to the right)
local content = Instance.new("Frame", main)
content.Size = UDim2.new(1, -NAV_W, 1, -56)
content.Position = UDim2.new(0, NAV_W, 0, 56)
content.BackgroundTransparency = 1

-- create page helper: returns a scrolling frame with managed layout, invisible at start
local Pages = {}
local currentPageName = nil
local function createPage(name)
    local p = Instance.new("ScrollingFrame")
    p.Name = name
    p.Size = UDim2.new(1, 0, 1, 0)
    p.Position = UDim2.new(0, 0, 0, 0)
    p.BackgroundTransparency = 1
    p.ScrollBarThickness = 6
    p.AutomaticCanvasSize = Enum.AutomaticSize.Y
    p.Parent = content
    p.Visible = false

    local layout = Instance.new("UIListLayout", p)
    layout.Padding = UDim.new(0,8)
    layout.SortOrder = Enum.SortOrder.LayoutOrder

    -- wire absolute content size to CanvasSize for robust scrolling
    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        local sizeY = layout.AbsoluteContentSize.Y
        p.CanvasSize = UDim2.new(0, 0, 0, sizeY + 8)
    end)
    return p
end

local function showPage(name)
    if currentPageName == name then return end
    local old = currentPageName and Pages[currentPageName] or nil
    local new = Pages[name]
    if not new then return end
    -- hide old quickly and stop any tween collisions
    if old and old ~= new then
        old.Visible = false
    end
    currentPageName = name
    -- show new
    new.Visible = true
    -- optional: small entrance tween for the content area (position the whole content frame once)
    -- we will skip complex sliding per-page to keep positioning stable and avoid overlap
end

-- nav button factory (keeps consistent spacing)
local function makeNavButton(text, order)
    local btn = Instance.new("TextButton", nav)
    btn.Size = UDim2.new(1, -12, 0, 40)
    btn.Position = UDim2.new(0, 6, 0, (order-1) * 48 + 10)
    btn.BackgroundColor3 = Color3.fromRGB(18,18,20)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(220,220,220)
    btn.Text = text
    local corner = Instance.new("UICorner", btn); corner.CornerRadius = UDim.new(0,8)
    local stroke = Instance.new("UIStroke", btn); stroke.Thickness = 1; registerStroke(stroke)
    return btn
end

-- Create pages and nav buttons
Pages.Tracker = createPage("Tracker")
Pages.History = createPage("History")
Pages.KillCounter = createPage("KillCounter")
Pages.Threats = createPage("Threats")
Pages.Misc = createPage("Misc")

local navButtons = {
    {name="Tracker", btn=makeNavButton("Tracker", 1)},
    {name="History", btn=makeNavButton("History", 2)},
    {name="KillCounter", btn=makeNavButton("Kills", 3)},
    {name="Threats", btn=makeNavButton("Threats", 4)},
    {name="Misc", btn=makeNavButton("Misc", 5)}
}
for _, v in ipairs(navButtons) do
    local pageName = v.name
    v.btn.MouseButton1Click:Connect(function() showPage(pageName) end)
end

-- create content of Tracker page (kept similar to your original)
local trackerHeader = Instance.new("TextLabel")
trackerHeader.Size = UDim2.new(1, -12, 0, 28)
trackerHeader.Position = UDim2.new(0, 6, 0, 6)
trackerHeader.BackgroundTransparency = 1
trackerHeader.Text = "Live Attackers"
trackerHeader.Font = Enum.Font.GothamBold
trackerHeader.TextSize = 16
trackerHeader.TextColor3 = Color3.fromRGB(230,230,230)
trackerHeader.Parent = Pages.Tracker
local thStroke = Instance.new("UIStroke", trackerHeader); registerStroke(thStroke)

-- live container inside Tracker page
local liveContainer = Instance.new("Frame", Pages.Tracker)
liveContainer.Size = UDim2.new(1, -12, 0, 180)
liveContainer.BackgroundTransparency = 1
liveContainer.LayoutOrder = 1

local liveScroll = Instance.new("ScrollingFrame", liveContainer)
liveScroll.Size = UDim2.new(1, 0, 1, 0)
liveScroll.Position = UDim2.new(0, 0, 0, 0)
liveScroll.BackgroundTransparency = 1
liveScroll.ScrollBarThickness = 6
local liveLayout = Instance.new("UIListLayout", liveScroll)
liveLayout.Padding = UDim.new(0,6)
liveLayout.SortOrder = Enum.SortOrder.LayoutOrder
liveContainer.Parent = Pages.Tracker

-- helper to clear only content rows (leave UIListLayout, etc)
local function clearContentRows(parentFrame)
    for _, child in ipairs(parentFrame:GetChildren()) do
        if child ~= liveLayout and not child:IsA("UIListLayout") and child ~= liveContainer and child.Name ~= "TrackerHeader" and (child:IsA("Frame") or child:IsA("TextLabel") or child:IsA("TextButton")) then
            child:Destroy()
        end
    end
end

local function makeLiveRow(name, hits)
    local row = Instance.new("Frame")
    row.Size = UDim2.new(1, 0, 0, 36)
    row.BackgroundColor3 = Color3.fromRGB(12,12,15)
    row.LayoutOrder = 0
    local rc = Instance.new("UICorner", row); rc.CornerRadius = UDim.new(0,8)
    local stroke = Instance.new("UIStroke", row); registerStroke(stroke)

    local label = Instance.new("TextLabel", row)
    label.Size = UDim2.new(0.6, -10, 1, 0)
    label.Position = UDim2.new(0, 8, 0, 0)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.Gotham
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextColor3 = Color3.fromRGB(230,230,230)
    label.Text = name

    local hitsLabel = Instance.new("TextLabel", row)
    hitsLabel.Size = UDim2.new(0.2, -6, 1, 0)
    hitsLabel.Position = UDim2.new(0.6, 8, 0, 0)
    hitsLabel.BackgroundTransparency = 1
    hitsLabel.Font = Enum.Font.Gotham
    hitsLabel.TextSize = 13
    hitsLabel.TextColor3 = Color3.fromRGB(200,200,200)
    hitsLabel.TextXAlignment = Enum.TextXAlignment.Center
    hitsLabel.Text = "Hits: " .. tostring(hits)

    local findBtn = Instance.new("TextButton", row)
    findBtn.Size = UDim2.new(0.2, -10, 0.7, 0)
    findBtn.Position = UDim2.new(0.8, 8, 0.15, 0)
    findBtn.BackgroundColor3 = Color3.fromRGB(32,32,36)
    findBtn.Font = Enum.Font.Gotham
    findBtn.TextSize = 12
    findBtn.Text = "Find"
    local fcorner = Instance.new("UICorner", findBtn)
    local fstroke = Instance.new("UIStroke", findBtn); registerStroke(fstroke)

    findBtn.MouseButton1Click:Connect(function()
        local pl = Players:FindFirstChild(name)
        if pl and pl.Character then
            local hl = Instance.new("Highlight")
            hl.Name = "_ATK_FindHighlight"
            hl.Adornee = pl.Character
            hl.Parent = PlayerGui -- safe place to parent highlight for local visibility
            if pl.TeamColor then hl.FillColor = pl.TeamColor.Color end
            task.delay(4, function() if hl and hl.Parent then hl:Destroy() end end)
        end
    end)
    return row
end

-- History page
local historyHeader = Instance.new("TextLabel")
historyHeader.Size = UDim2.new(1, -12, 0, 28)
historyHeader.Position = UDim2.new(0, 6, 0, 6)
historyHeader.BackgroundTransparency = 1
historyHeader.Text = "History (recent)"
historyHeader.Font = Enum.Font.GothamBold
historyHeader.TextSize = 16
historyHeader.TextColor3 = Color3.fromRGB(230,230,230)
historyHeader.Parent = Pages.History
local historyScroll = Instance.new("ScrollingFrame", Pages.History)
historyScroll.Size = UDim2.new(1, -12, 1, -44)
historyScroll.Position = UDim2.new(0, 6, 0, 44)
historyScroll.BackgroundTransparency = 1
historyScroll.ScrollBarThickness = 6
local historyLayout = Instance.new("UIListLayout", historyScroll)
historyLayout.Padding = UDim.new(0,6)
historyLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    historyScroll.CanvasSize = UDim2.new(0,0,0, historyLayout.AbsoluteContentSize.Y + 8)
end)

local function makeHistoryRow(item)
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(1, -12, 0, 28)
    lbl.BackgroundTransparency = 0.12
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    local fromT = os.date("%H:%M:%S", item.timeFirst)
    local toT = os.date("%H:%M:%S", item.timeLast)
    lbl.Text = string.format("%s — hits: %d — %s → %s", item.name, item.hits, fromT, toT)
    lbl.Parent = historyScroll
end

-- Kill counter page simplified (list auto-populates)
local kcHeader = Instance.new("TextLabel")
kcHeader.Size = UDim2.new(1, -12, 0, 28)
kcHeader.Position = UDim2.new(0, 6, 0, 6)
kcHeader.BackgroundTransparency = 1
kcHeader.Text = "Kill Counter (select a player)"
kcHeader.Font = Enum.Font.GothamBold
kcHeader.TextSize = 16
kcHeader.TextColor3 = Color3.fromRGB(230,230,230)
kcHeader.Parent = Pages.KillCounter

local kcList = Instance.new("ScrollingFrame", Pages.KillCounter)
kcList.Size = UDim2.new(1, -12, 1, -120)
kcList.Position = UDim2.new(0, 6, 0, 44)
kcList.BackgroundTransparency = 1
kcList.ScrollBarThickness = 6
local kcLayout = Instance.new("UIListLayout", kcList)
kcLayout.Padding = UDim.new(0,6)
kcLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    kcList.CanvasSize = UDim2.new(0,0,0, kcLayout.AbsoluteContentSize.Y + 8)
end)

local selectedLabel = Instance.new("TextLabel", Pages.KillCounter)
selectedLabel.Size = UDim2.new(1, -12, 0, 28)
selectedLabel.Position = UDim2.new(0, 6, 1, -64)
selectedLabel.BackgroundTransparency = 1
selectedLabel.Font = Enum.Font.GothamBold
selectedLabel.TextSize = 14
selectedLabel.TextColor3 = Color3.fromRGB(235,235,235)
selectedLabel.Text = "Selected: (none)"

local kdInfo = Instance.new("TextLabel", Pages.KillCounter)
kdInfo.Size = UDim2.new(1, -12, 0, 28)
kdInfo.Position = UDim2.new(0, 6, 1, -36)
kdInfo.BackgroundTransparency = 1
kdInfo.Font = Enum.Font.Gotham
kdInfo.TextSize = 13
kdInfo.TextColor3 = Color3.fromRGB(200,200,200)
kdInfo.Text = "Kills: 0    Deaths: 0"

local function refreshKillList()
    for _, c in ipairs(kcList:GetChildren()) do if c:IsA("TextButton") then c:Destroy() end end
    local y = 0
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer then
            local btn = Instance.new("TextButton")
            btn.Size = UDim2.new(1, -8, 0, 30)
            btn.Position = UDim2.new(0, 4, 0, y)
            btn.Text = pl.Name
            btn.Font = Enum.Font.Gotham
            btn.TextSize = 14
            btn.TextColor3 = Color3.fromRGB(240,240,240)
            btn.BackgroundColor3 = Color3.fromRGB(18,18,20)
            btn.Parent = kcList
            local corner = Instance.new("UICorner", btn)
            local stroke = Instance.new("UIStroke", btn); registerStroke(stroke)
            btn.MouseButton1Click:Connect(function()
                selectedForKillTrack = pl.Name
                killTrack[selectedForKillTrack] = killTrack[selectedForKillTrack] or {kills = 0, deaths = 0}
                selectedLabel.Text = "Selected: " .. selectedForKillTrack
                kdInfo.Text = string.format("Kills: %d    Deaths: %d", killTrack[selectedForKillTrack].kills or 0, killTrack[selectedForKillTrack].deaths or 0)
            end)
            y = y + 36
        end
    end
    kcList.CanvasSize = UDim2.new(0,0,0, y)
end
Players.PlayerAdded:Connect(refreshKillList)
Players.PlayerRemoving:Connect(function(pl)
    if pl.Name == selectedForKillTrack then
        selectedForKillTrack = nil
        selectedLabel.Text = "Selected: (none)"
        kdInfo.Text = "Kills: 0    Deaths: 0"
    end
    refreshKillList()
end)
refreshKillList()

-- Threats page
local threatsHeader = Instance.new("TextLabel")
threatsHeader.Size = UDim2.new(1, -12, 0, 28)
threatsHeader.Position = UDim2.new(0, 6, 0, 6)
threatsHeader.BackgroundTransparency = 1
threatsHeader.Text = "Threats"
threatsHeader.Font = Enum.Font.GothamBold
threatsHeader.TextSize = 16
threatsHeader.TextColor3 = Color3.fromRGB(230,230,230)
threatsHeader.Parent = Pages.Threats

local threatsLeft = Instance.new("Frame", Pages.Threats)
threatsLeft.Size = UDim2.new(0.5, -8, 1, -44)
threatsLeft.Position = UDim2.new(0, 6, 0, 44)
threatsLeft.BackgroundTransparency = 1
local threatsRight = threatsLeft:Clone()
threatsRight.Parent = Pages.Threats
threatsRight.Position = UDim2.new(0.5, 2, 0, 44)

local function computeThreatForPlayer(pl)
    local score = 0
    local data = attackers[pl.Name]
    if data then score = score + data.hits * 2 end
    local char = pl.Character
    if char and char:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local d = (char.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        if d < 10 then score = score + 4
        elseif d < 25 then score = score + 2
        elseif d < 60 then score = score + 1 end
    end
    for _,c in ipairs(pl.Character and pl.Character:GetChildren() or {}) do
        if c:IsA("Tool") then score = score + 2; break end
    end
    return score
end

local function threatLabelForScore(score)
    if score >= 8 then return "Dangerous", Color3.fromRGB(200,20,20) end
    if score >= 5 then return "High", Color3.fromRGB(230,90,10) end
    if score >= 3 then return "Medium", Color3.fromRGB(230,200,20) end
    return "Low", Color3.fromRGB(100,200,100)
end

local function refreshThreats()
    for _,c in ipairs(threatsLeft:GetChildren()) do if c:IsA("TextLabel") or c:IsA("Frame") then c:Destroy() end end
    for _,c in ipairs(threatsRight:GetChildren()) do if c:IsA("TextLabel") or c:IsA("Frame") then c:Destroy() end end

    local players = {}
    for _,pl in ipairs(Players:GetPlayers()) do if pl ~= LocalPlayer then table.insert(players, pl) end end
    table.sort(players, function(a,b) return computeThreatForPlayer(a) > computeThreatForPlayer(b) end)

    for i=1, math.min(10, #players) do
        local side = (i <= 5) and threatsLeft or threatsRight
        local idx = ((i-1) % 5)
        local pl = players[i]
        local score = computeThreatForPlayer(pl)
        local lbl, color = threatLabelForScore(score)
        local text = string.format("%s — Threat: %s", pl.Name, lbl)
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -8, 0, 28)
        label.Position = UDim2.new(0, 6, 0, idx * 34)
        label.BackgroundTransparency = 0.12
        label.Font = Enum.Font.Gotham
        label.TextSize = 13
        label.TextColor3 = color
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Text = text
        label.Parent = side
        local stroke = Instance.new("UIStroke", label); registerStroke(stroke)
    end
end

-- Misc page (current attacker)
local miscHeader = Instance.new("TextLabel")
miscHeader.Size = UDim2.new(1, -12, 0, 28)
miscHeader.Position = UDim2.new(0, 6, 0, 6)
miscHeader.BackgroundTransparency = 1
miscHeader.Text = "Misc / Current Attacker"
miscHeader.Font = Enum.Font.GothamBold
miscHeader.TextSize = 16
miscHeader.TextColor3 = Color3.fromRGB(230,230,230)
miscHeader.Parent = Pages.Misc

local currentLabel = Instance.new("TextLabel", Pages.Misc)
currentLabel.Size = UDim2.new(1, -12, 0, 24)
currentLabel.Position = UDim2.new(0, 6, 0, 44)
currentLabel.BackgroundTransparency = 1
currentLabel.Font = Enum.Font.Gotham
currentLabel.TextSize = 14
currentLabel.TextColor3 = Color3.fromRGB(230,230,230)
currentLabel.Text = "Current Attacker: (none)"

local statsFrame = Instance.new("Frame", Pages.Misc)
statsFrame.Size = UDim2.new(1, -12, 0, 100)
statsFrame.Position = UDim2.new(0, 6, 0, 76)
statsFrame.BackgroundTransparency = 1
local leftStats = Instance.new("TextLabel", statsFrame)
leftStats.Size = UDim2.new(0.5, -6, 1, 0)
leftStats.Position = UDim2.new(0, 0, 0, 0)
leftStats.BackgroundTransparency = 1
leftStats.Font = Enum.Font.Gotham
leftStats.TextSize = 13
leftStats.TextColor3 = Color3.fromRGB(210,210,210)
leftStats.TextXAlignment = Enum.TextXAlignment.Left

local rightStats = leftStats:Clone()
rightStats.Parent = statsFrame
rightStats.Position = UDim2.new(0.5, 6, 0, 0)
rightStats.TextXAlignment = Enum.TextXAlignment.Left

local findAttackerBtn = Instance.new("TextButton", Pages.Misc)
findAttackerBtn.Size = UDim2.new(0, 160, 0, 36)
findAttackerBtn.Position = UDim2.new(0.5, -80, 1, -60)
findAttackerBtn.Text = "Find Attacker"
findAttackerBtn.Font = Enum.Font.GothamBold
local findCorner = Instance.new("UICorner", findAttackerBtn)
local findStroke = Instance.new("UIStroke", findAttackerBtn); registerStroke(findStroke)

local currentAttackerName = nil
findAttackerBtn.MouseButton1Click:Connect(function()
    if not currentAttackerName then return end
    local pl = Players:FindFirstChild(currentAttackerName)
    if pl and pl.Character then
        local hl = Instance.new("Highlight")
        hl.Adornee = pl.Character
        hl.Parent = PlayerGui
        if pl.TeamColor then hl.FillColor = pl.TeamColor.Color end
        task.delay(5, function() if hl and hl.Parent then hl:Destroy() end end)
    end
end)

-- small animated notice helper
local function smallNotice(text, duration)
    duration = duration or 1.6
    local fg = Instance.new("Frame", screen)
    fg.Size = UDim2.new(0, 260, 0, 60)
    fg.Position = UDim2.new(0.5, -130, 0.12, 0)
    fg.AnchorPoint = Vector2.new(0.5, 0)
    fg.BackgroundColor3 = Color3.fromRGB(18,18,22)
    local rc = Instance.new("UICorner", fg); rc.CornerRadius = UDim.new(0,10)
    local st = Instance.new("UIStroke", fg); registerStroke(st)
    local lbl = Instance.new("TextLabel", fg)
    lbl.Size = UDim2.new(1, -12, 1, -12)
    lbl.Position = UDim2.new(0, 6, 0, 6)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.GothamBold
    lbl.TextSize = 16
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.Text = text

    fg.Position = UDim2.new(0.5, -130, -0.2, 0)
    fg:TweenPosition(UDim2.new(0.5, -130, 0.12, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.28, true)
    task.delay(duration, function()
        fg:TweenPosition(UDim2.new(0.5, -130, -0.2, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.28, true)
        task.delay(0.28, function() if fg and fg.Parent then fg:Destroy() end end)
    end)
end

-- open/close functions (clean)
local function openTracker()
    smallNotice("Opening tracker...")
    task.delay(0.65, function()
        main.Visible = true
        main:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.35, true)
    end)
end
local function closeTracker()
    smallNotice("Closing tracker...")
    task.delay(0.65, function()
        main:TweenPosition(UDim2.new(0.5, 0, -0.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.35, true)
        task.delay(0.36, function() main.Visible = false end)
    end)
end
local function toggleTracker()
    if not main.Visible then openTracker() else closeTracker() end
end

-- chat handling (same as before)
if TextChatService and TextChatService.MessageReceived then
    TextChatService.MessageReceived:Connect(function(msg)
        local source = nil
        pcall(function() source = msg.TextSource end)
        local fromLocal = false
        if source then
            if pcall(function() return source.Name end) and source.Name == LocalPlayer.Name then fromLocal = true end
            if not fromLocal and pcall(function() return source.UserId end) and source.UserId == LocalPlayer.UserId then fromLocal = true end
        end
        if not fromLocal then return end
        local txt = (msg.Text or ""):lower():gsub("^%s*(.-)%s*$","%1")
        if txt == "/tracker" or txt == "/trackeropen" then openTracker()
        elseif txt == "/trackerclose" then closeTracker() end
    end)
else
    LocalPlayer.Chatted:Connect(function(msg)
        local txt = (msg or ""):lower():gsub("^%s*(.-)%s*$","%1")
        if txt == "/tracker" or txt == "/trackeropen" then openTracker()
        elseif txt == "/trackerclose" then closeTracker() end
    end)
end

-- ====================
-- UI refresh loop (uses robust Canvas size and layout)
-- ====================
spawn(function()
    -- small demo seeding to let you visually test layout at first run.
    -- remove in production.
    if #history == 0 and next(attackers) == nil then
        -- demo attackers
        registerAttacker("player_one_demo")
        registerAttacker("player_two_demo")
        registerAttacker("player_three_demo")
        archiveAttacker("player_two_demo")
    end

    while screen.Parent do
        -- housekeeping
        cleanupInactive()

        -- Tracker page refresh
        -- clear existing rows then repopulate
        for _, c in ipairs(liveScroll:GetChildren()) do
            if not c:IsA("UIListLayout") then c:Destroy() end
        end
        -- add header spacer label
        local spacer = Instance.new("TextLabel")
        spacer.Size = UDim2.new(1, -12, 0, 6)
        spacer.BackgroundTransparency = 1
        spacer.Parent = liveScroll

        local nowt = now()
        local liveCount = 0
        -- stable iteration for deterministic ordering
        local keys = {}
        for name, data in pairs(attackers) do table.insert(keys, {name=name, last=data.lastHit, hits=data.hits}) end
        table.sort(keys, function(a,b) return a.last > b.last end)
        for _, v in ipairs(keys) do
            local row = makeLiveRow(v.name, v.hits)
            row.Parent = liveScroll
            liveCount = liveCount + 1
        end
        -- update CanvasSize via AbsoluteContentSize (UIListLayout auto-handles)

        -- History page refresh (top 50)
        for _, c in ipairs(historyScroll:GetChildren()) do
            if not c:IsA("UIListLayout") then c:Destroy() end
        end
        for i=1, math.min(50, #history) do
            makeHistoryRow(history[i])
        end

        -- Kill counter info display
        if selectedForKillTrack then
            local info = killTrack[selectedForKillTrack] or {kills = 0, deaths = 0}
            kdInfo.Text = string.format("Kills: %d    Deaths: %d", info.kills or 0, info.deaths or 0)
            selectedLabel.Text = "Selected: " .. selectedForKillTrack
        end

        -- threats
        refreshThreats()

        -- current attacker misc
        local mostRecentName, mostRecentTime = nil, -1
        for name,data in pairs(attackers) do
            if data.lastHit and data.lastHit > mostRecentTime then
                mostRecentTime, mostRecentName = data.lastHit, name
            end
        end
        currentAttackerName = mostRecentName
        if currentAttackerName then
            currentLabel.Text = "Current Attacker: " .. tostring(currentAttackerName)
            local pl = Players:FindFirstChild(currentAttackerName)
            if pl and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local dist = math.floor((pl.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude)
                local ws, jp = "N/A", "N/A"
                local hum = pl.Character:FindFirstChildOfClass("Humanoid")
                if hum then ws = tostring(math.floor(hum.WalkSpeed or 0)) jp = tostring(math.floor(hum.JumpPower or hum.JumpHeight or 0)) end
                leftStats.Text = string.format("WalkSpeed: %s\nJumpPower: %s\nDistance: %d studs", ws, jp, dist)
                local toolsUsed = {}
                for _, c in ipairs(pl.Character:GetChildren()) do if c:IsA("Tool") then table.insert(toolsUsed, c.Name) end end
                if #toolsUsed == 0 then rightStats.Text = "Tools: (none detected)\nDamage: (n/a)" else rightStats.Text = "Tools: "..table.concat(toolsUsed, ", ").."\nDamage: (n/a)" end
            else
                leftStats.Text = "WalkSpeed: N/A\nJumpPower: N/A\nDistance: N/A"
                rightStats.Text = "Tools: N/A\nDamage: N/A"
            end
        else
            currentLabel.Text = "Current Attacker: (none)"
            leftStats.Text = ""
            rightStats.Text = ""
        end

        -- update kill list
        refreshKillList()

        task.wait(UI_POLL)
    end
end)

-- ====================
-- Public API
-- ====================
_G.AttackerTracker = {
    Register = registerAttacker,
    Archive = archiveAttacker,
    GetCurrent = function() local t={} for k,v in pairs(attackers) do t[k]=v end return t end,
    GetHistory = function() return history end,
    Open = openTracker,
    Close = closeTracker,
    Toggle = toggleTracker,
    SetSelectedKillTarget = function(name)
        if not name then selectedForKillTrack = nil; return end
        if Players:FindFirstChild(name) then
            selectedForKillTrack = name
            killTrack[selectedForKillTrack] = killTrack[selectedForKillTrack] or {kills = 0, deaths = 0}
        end
    end,
    ResetAll = function()
        attackers = {}
        history = {}
        recentHits = {}
        killTrack = {}
        selectedForKillTrack = nil
    end
}

print("[AttackerTracker] UI rebuilt & initialized. Use /tracker to open.")
